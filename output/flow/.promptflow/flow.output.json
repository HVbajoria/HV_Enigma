{
  "answer": "### Jumping Over Bookstacks to Chocolate Land\n\n**Tags:** Algorithm, Dynamic Programming, Longest Increasing Subsequence\n\n**Topics:** Arrays, Sequences, Optimization\n\n**Companies:** Google, Facebook, Amazon, Microsoft\n\n---\n\nThis problem involves finding the longest subsequence of book heights that Manish can jump on in non-decreasing order, ultimately helping him reach the land of chocolates. It is a classic example of the Longest Increasing Subsequence (LIS) problem, which can be efficiently solved using dynamic programming techniques. The given solution leverages a combination of a vector and binary search to achieve optimal performance.\n\n### Problem Summary\nManish must jump across books whose heights are given in an array. He can only jump to a book if its height is greater than or equal to the current book he is on. The goal is to determine the maximum number of books he can jump on in this manner.\n\n### Input\n- Integer \\( n \\) representing the number of books.\n- Array of integers representing the heights of the books.\n\n### Output\n- An integer representing the maximum number of books Manish can jump on following the non-decreasing order rule.\n\n### Example\n**Input:**\n```\n5\n2 5 3 7 11\n```\n\n**Output:**\n```\n4\n```\n\n**Explanation:**\nManish can jump on books with heights 2, 3, 7, and 11.\n\n### Solution Explanation\nThe provided solution uses a vector `a` to keep track of the longest sequence of non-decreasing book heights. For each book's height, it determines the appropriate position in the vector using `lower_bound`. If the height is larger than all elements in the vector, it is appended to the end. Otherwise, it replaces the first element in the vector that is not smaller than the height. This method ensures that the vector `a` always contains the smallest possible end elements for subsequences of various lengths, allowing the length of the vector to represent the length of the longest non-decreasing subsequence.\n\n### Code\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a;\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        auto it = lower_bound(a.begin(), a.end(), x);\n        if (it == a.end()) {\n            a.push_back(x);\n        } else {\n            a[it - a.begin()] = x;\n        }\n    }\n    cout << a.size() << endl;\n    return 0;\n}\n```\n\nThis approach ensures that the solution is efficient and can handle the upper constraints of the problem.\n\n### Problem Statement\n\nManish wants to reach the land of chocolates where he can collect as many chocolates as possible. However, to get there, he must overcome a series of obstacles, each represented by a book of varying heights. Manish can only proceed by jumping on books in non-decreasing order of their heights. \n\nGiven the heights of the books, your task is to determine the maximum number of books Manish can jump on in a non-decreasing order on his way to the land of chocolates.\n\n### Input Format\n\n- The first line of the input contains a single integer \\( n \\) – the number of books.\n- The second line of the input contains \\( n \\) integers \\( a_1, a_2, \\ldots, a_n \\) – the heights of the books, where \\( a_i \\) represents the height of the \\( i \\)-th book from the left.\n\n### Output Format\n\n- Output a single integer – the maximum number of books Manish can jump on in non-decreasing order.\n\n### Constraints\n\n- \\( 1 \\leq n \\leq 10^5 \\)\n- \\( 1 \\leq a_i \\leq 10^9 \\)\n\n### Sample Test Cases\n\n#### Sample Input 1\n```\n5\n2 5 3 7 11\n```\n\n#### Sample Output 1\n```\n4\n```\n\n#### Explanation 1\nManish can jump on the books in the order of their heights as follows: 2, 3, 7, 11. This sequence is non-decreasing and includes 4 books.\n\n#### Sample Input 2\n```\n6\n1 2 3 4 5 6\n```\n\n#### Sample Output 2\n```\n6\n```\n\n#### Explanation 2\nManish can jump on all the books as their heights are already in non-decreasing order.\n\n### Solution Code\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a;\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        auto it = lower_bound(a.begin(), a.end(), x);\n        if (it == a.end()) {\n            a.push_back(x);\n        } else {\n            a[it - a.begin()] = x;\n        }\n    }\n    cout << a.size() << endl;\n    return 0;\n}\n```\n\nSure, I'll rephrase the solution code according to the problem statement and modify the variable names, function name, and comments accordingly. Here is the updated code:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // Number of books\n    int numBooks;\n    cin >> numBooks;\n    \n    // Heights of the books\n    vector<int> bookHeights;\n    \n    for (int i = 0; i < numBooks; i++) {\n        int height;\n        cin >> height;\n        \n        // Find the position to replace or extend the sequence\n        auto pos = lower_bound(bookHeights.begin(), bookHeights.end(), height);\n        \n        if (pos == bookHeights.end()) {\n            // If height is greater than any element in bookHeights, add it to the end\n            bookHeights.push_back(height);\n        } else {\n            // Replace the element at the found position\n            bookHeights[pos - bookHeights.begin()] = height;\n        }\n    }\n    \n    // The size of bookHeights is the maximum number of books Manish can jump on\n    cout << bookHeights.size() << endl;\n    \n    return 0;\n}\n```\n\n### Explanation of Changes:\n1. **Variable Names:**\n   - `n` is changed to `numBooks` to represent the number of books.\n   - `a` is changed to `bookHeights` to represent the heights of the books.\n   - `x` is changed to `height` to represent the current book height being read.\n   - `it` is changed to `pos` to represent the position found using `lower_bound`.\n\n2. **Comments:**\n   - Added comments to explain the purpose of each section of the code.\n\n3. **Input/Output:**\n   - The code now reads the number of books and their heights from the input and outputs the maximum number of books Manish can jump on in non-decreasing order.\n\nThis code maintains the logic of the original solution but adapts the naming and comments to fit the context of the problem statement about Manish and the land of chocolates.\n\n## Editorial: Maximum Number of Books Manish Can Jump On\n\n### Intuition\n\nThe problem requires us to determine the maximum number of books that Manish can jump on in a non-decreasing order of their heights. Essentially, this is a classic problem of finding the longest non-decreasing subsequence in an array, which is a well-known dynamic programming problem with an efficient solution using binary search.\n\n### Approach\n\nTo solve this problem, we can leverage the concept of the Longest Increasing Subsequence (LIS), but with slight modifications to handle non-decreasing order. The key steps are:\n\n1. **Dynamic Programming with Binary Search**: We maintain an array `dp` where each element `dp[i]` represents the minimum possible ending value of a subsequence of length `i+1` that is non-decreasing.\n  \n2. **Binary Search for Efficiency**: For each height in the list of books, we use binary search to find the position where this height can extend or replace an element in `dp` to maintain the longest non-decreasing subsequence.\n\n3. **Updating the `dp` Array**: If the height can extend the subsequence, it is appended to `dp`. If it replaces an existing value, it ensures the subsequence remains non-decreasing and potentially allows for longer subsequences in future iterations.\n\n### Code\n\nHere is the implementation in C++:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    vector<int> dp;\n    for (int i = 0; i < n; i++) {\n        auto it = lower_bound(dp.begin(), dp.end(), a[i]);\n        if (it == dp.end()) {\n            dp.push_back(a[i]);\n        } else {\n            *it = a[i];\n        }\n    }\n\n    cout << dp.size() << endl;\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Reading Input**: \n   - The number of books `n` and their respective heights are read into an array `a`.\n\n2. **Dynamic Programming Array Initialization**:\n   - We initialize an empty vector `dp` which will be used to store the minimum end values of subsequences of different lengths.\n\n3. **Processing Each Book Height**:\n   - For each height `a[i]` in the array, we use the `lower_bound` function to find the first element in `dp` that is not less than `a[i]`.\n   - If `lower_bound` returns an iterator pointing to the end of `dp`, it means `a[i]` is greater than all current elements in `dp`, so we append `a[i]` to `dp`.\n   - Otherwise, we replace the element pointed to by the iterator with `a[i]` to maintain the smallest possible ending value for subsequences of that length.\n\n4. **Result**:\n   - The size of the `dp` array at the end of the loop represents the length of the longest non-decreasing subsequence, which is the maximum number of books Manish can jump on.\n\n### Conclusion\n\nThis approach ensures an efficient O(n log n) solution due to the use of binary search within the dynamic programming framework. The problem is effectively a variation of finding the Longest Increasing Subsequence, adapted to handle non-decreasing sequences, and the solution leverages well-known techniques to achieve optimal performance.\n\n\n\n### Program to generate testcases:\n\nCertainly! Below is a Python script that generates the required test cases and stores them in appropriate files. It also includes the mechanism to run the solution code (assumed to be in `solution.py`) and store the output in corresponding files.\n\n```python\nimport os\nimport subprocess\n\n# Function to write test case to a file\ndef write_test_case(filename, content):\n    with open(filename, 'w') as f:\n        f.write(content)\n\n# Function to run solution.py and capture the output\ndef run_solution(input_filename, output_filename):\n    with open(input_filename, 'r') as infile, open(output_filename, 'w') as outfile:\n        subprocess.run(['python3', 'solution.py'], stdin=infile, stdout=outfile)\n\n# Basic Test Cases\nbasic_test_cases = [\n    \"5\\n2 5 3 7 11\\n\",  # Example from the problem statement\n    \"6\\n1 2 3 4 5 6\\n\",  # Already sorted\n    \"3\\n10 20 30\\n\",  # Simple increasing\n    \"4\\n4 4 4 4\\n\"  # All same height\n]\n\n# Corner Test Cases\ncorner_test_cases = [\n    \"1\\n1000000000\\n\",  # Single book with max height\n    \"2\\n1 1000000000\\n\"  # Two books with min and max heights\n]\n\n# Edge Test Cases\nedge_test_cases = [\n    \"5\\n5 4 3 2 1\\n\",  # Strictly decreasing\n    \"5\\n1 3 2 4 5\\n\"  # Mixed order\n]\n\n# Boundary Test Cases\nboundary_test_cases = [\n    \"100000\\n\" + \" \".join(map(str, range(1, 100001))) + \"\\n\",  # Maximum n with increasing order\n    \"100000\\n\" + \" \".join(map(str, range(100000, 0, -1))) + \"\\n\"  # Maximum n with decreasing order\n]\n\n# Directory to store test cases and outputs\nos.makedirs('test_cases', exist_ok=True)\n\n# Write and run basic test cases\nfor i, test_case in enumerate(basic_test_cases, 1):\n    input_filename = f'test_cases/basic_input_{i}.txt'\n    output_filename = f'test_cases/basic_output_{i}.txt'\n    write_test_case(input_filename, test_case)\n    run_solution(input_filename, output_filename)\n\n# Write and run corner test cases\nfor i, test_case in enumerate(corner_test_cases, 1):\n    input_filename = f'test_cases/corner_input_{i}.txt'\n    output_filename = f'test_cases/corner_output_{i}.txt'\n    write_test_case(input_filename, test_case)\n    run_solution(input_filename, output_filename)\n\n# Write and run edge test cases\nfor i, test_case in enumerate(edge_test_cases, 1):\n    input_filename = f'test_cases/edge_input_{i}.txt'\n    output_filename = f'test_cases/edge_output_{i}.txt'\n    write_test_case(input_filename, test_case)\n    run_solution(input_filename, output_filename)\n\n# Write and run boundary test cases\nfor i, test_case in enumerate(boundary_test_cases, 1):\n    input_filename = f'test_cases/boundary_input_{i}.txt'\n    output_filename = f'test_cases/boundary_output_{i}.txt'\n    write_test_case(input_filename, test_case)\n    run_solution(input_filename, output_filename)\n```\n\n### Explanation:\n1. **Test Case Generation**:\n    - **Basic Test Cases**: Four test cases covering normal scenarios.\n    - **Corner Test Cases**: Two test cases covering the smallest and the largest possible values.\n    - **Edge Test Cases**: Two test cases covering edge scenarios like strictly decreasing order.\n    - **Boundary Test Cases**: Two test cases covering the maximum constraints.\n\n2. **File Handling**:\n    - Each test case is written to a corresponding input file.\n    - The solution is run using `subprocess.run()`, and the output is captured and written to the corresponding output file.\n\n3. **Assumptions**:\n    - The solution code is in `solution.py` and can be run with `python3`.\n    - The test cases and output files are stored in a directory called `test_cases`.\n\nMake sure the `solution.py` file is in the same directory as this script, and it is designed to read from standard input and write to standard output."
}