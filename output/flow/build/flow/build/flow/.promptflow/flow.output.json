{
  "answer": "### Question Name:\n**\"Avantika's Chessboard Conundrum: The n-Queens Challenge\"**\n\n### Tags:\n- Algorithm\n- Backtracking\n- Recursion\n- Chess\n- Combinatorial Problems\n\n### Topics:\n- Backtracking\n- Combinatorial Search\n- Dynamic Programming\n- Optimization Problems\n\n### Companies:\n- Google\n- Facebook\n- Amazon\n- Microsoft\n- Apple\n\n### Additional Context:\nThis problem is often encountered in technical interviews for software engineering positions, especially in companies that emphasize algorithmic proficiency and problem-solving skills. The n-queens puzzle is a classic example used to test a candidate's understanding of backtracking algorithms and their ability to handle combinatorial search problems.\n\n## Problem Statement\n\n### Story: Avantika's Quest to Win the Chess Challenge\n\nAvantika is engaged in an intense chess match with her friend Srey. To secure her victory, she needs to solve a classic chess puzzle: the n-queens puzzle. The challenge is to place `n` queens on an `n x n` chessboard in such a way that no two queens can attack each other. \n\nGiven an integer `n`, your task is to help Avantika find all distinct solutions to the n-queens puzzle. Each solution should represent a unique configuration of the n-queens placement, where the solutions are permutations of `[1, 2, 3, ..., n]` in increasing order. In each permutation, the number in the `i-th` position indicates that the queen in the `i-th` column is placed in the row with that number.\n\nFor example, the permutation `[3, 1, 4, 2]` represents the following chessboard configuration:\n```\n. . Q .\nQ . . .\n. . . Q\n. Q . .\n```\n\n### Constraints\n\n- \\(1 \\leq n \\leq 10^5\\)\n\n### Input Format\n\n- A single integer `n` representing the size of the chessboard and the number of queens to be placed.\n\n### Output Format\n\n- A list of lists, where each inner list represents a distinct board configuration of the n-queens placement as described above.\n\n### Example\n\n#### Example 1:\n**Input:**\n```plaintext\n4\n```\n\n**Output:**\n```plaintext\n[[2, 4, 1, 3], [3, 1, 4, 2]]\n```\n\n**Explanation:**\nThe output represents two distinct configurations:\n1. `[2, 4, 1, 3]`\n   ```\n   . Q . .\n   . . . Q\n   Q . . .\n   . . Q .\n   ```\n2. `[3, 1, 4, 2]`\n   ```\n   . . Q .\n   Q . . .\n   . . . Q\n   . Q . .\n   ```\n\n#### Example 2:\n**Input:**\n```plaintext\n1\n```\n\n**Output:**\n```plaintext\n[[1]]\n```\n\n**Explanation:**\nThe output represents the only configuration for `n=1`:\n1. `[1]`\n   ```\n   Q\n   ```\n\n### Solution Code\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> ans;\n    \n    bool check(vector<vector<char>>& board, int i, int j) {\n        int x = i, y = j;\n        // Check upward direction\n        while(x >= 0) {\n            if(board[x][y] == 'Q') {\n                return false;\n            }\n            x--;\n        }\n        // Check left diagonal upward direction\n        x = i, y = j;\n        while(x >= 0 && y >= 0) {\n            if(board[x][y] == 'Q') return false;\n            x--;\n            y--;\n        }\n        // Check right diagonal upward direction\n        x = i, y = j;\n        while(x >= 0 && y < board.size()) {\n            if(board[x][y] == 'Q') return false;\n            x--;\n            y++;\n        }\n        return true;\n    }\n    \n    void insertAns(vector<vector<char>>& board) {\n        vector<int> row;\n        for(int i = 0; i < board.size(); i++) {\n            for(int j = 0; j < board.size(); j++) {\n                if(board[j][i] == 'Q') {\n                    row.push_back(j + 1);\n                    break;\n                }\n            }\n        }\n        if(row.size() == board.size()) {\n            ans.push_back(row);\n        }\n    }\n\n    void solve(vector<vector<char>>& board, int i, int n) {\n        if(i >= n) {\n            insertAns(board);\n            return;\n        }\n        \n        for(int j = 0; j < board.size(); j++) {\n            if(check(board, i, j)) {\n                board[i][j] = 'Q';\n                solve(board, i + 1, n);\n                board[i][j] = '-';\n            }\n        }\n    }\n\n    vector<vector<int>> nQueen(int n) {\n        vector<vector<char>> board(n, vector<char>(n, '-'));\n        solve(board, 0, n);\n        sort(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```\n\nSure, I'll rephrase the solution code to match the problem statement and take user input based on the given format.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass ChessSolver {\npublic:\n    vector<vector<int>> solutions;\n    \n    // Function to check if placing a queen at (row, col) is safe\n    bool isSafe(vector<vector<char>>& board, int row, int col) {\n        int x = row, y = col;\n        // Check upward direction\n        while(x >= 0) {\n            if(board[x][y] == 'Q') {\n                return false;\n            }\n            x--;\n        }\n        // Check left diagonal upward direction\n        x = row, y = col;\n        while(x >= 0 && y >= 0) {\n            if(board[x][y] == 'Q') return false;\n            x--;\n            y--;\n        }\n        // Check right diagonal upward direction\n        x = row, y = col;\n        while(x >= 0 && y < board.size()) {\n            if(board[x][y] == 'Q') return false;\n            x--;\n            y++;\n        }\n        return true;\n    }\n    \n    // Function to record a valid board configuration\n    void recordSolution(vector<vector<char>>& board) {\n        vector<int> configuration;\n        for(int i = 0; i < board.size(); i++) {\n            for(int j = 0; j < board.size(); j++) {\n                if(board[j][i] == 'Q') {\n                    configuration.push_back(j + 1);\n                    break;\n                }\n            }\n        }\n        if(configuration.size() == board.size()) {\n            solutions.push_back(configuration);\n        }\n    }\n\n    // Recursive function to solve the n-queens problem\n    void solveNQueens(vector<vector<char>>& board, int row, int n) {\n        if(row >= n) {\n            recordSolution(board);\n            return;\n        }\n        \n        for(int col = 0; col < board.size(); col++) {\n            if(isSafe(board, row, col)) {\n                board[row][col] = 'Q';\n                solveNQueens(board, row + 1, n);\n                board[row][col] = '-';\n            }\n        }\n    }\n\n    // Main function to find all n-queens solutions\n    vector<vector<int>> findNQueensSolutions(int n) {\n        vector<vector<char>> board(n, vector<char>(n, '-'));\n        solveNQueens(board, 0, n);\n        sort(solutions.begin(), solutions.end());\n        return solutions;\n    }\n};\n\nint main() {\n    int n;\n    cout << \"Enter the size of the chessboard: \";\n    cin >> n;\n\n    ChessSolver solver;\n    vector<vector<int>> result = solver.findNQueensSolutions(n);\n\n    cout << \"Distinct solutions to the \" << n << \"-queens puzzle are:\\n\";\n    for(const auto& solution : result) {\n        for(int pos : solution) {\n            cout << pos << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```\n\nIn this code:\n- The class `Solution` has been renamed to `ChessSolver`.\n- The function `nQueen` has been renamed to `findNQueensSolutions`.\n- The function `check` has been renamed to `isSafe`.\n- The function `insertAns` has been renamed to `recordSolution`.\n- The function `solve` has been renamed to `solveNQueens`.\n- The main function takes user input for the size of the chessboard and prints the solutions.\n\n## Editorial: Solving the N-Queens Puzzle\n\n### Intuition\n\nThe N-Queens puzzle is a classic problem of placing `n` queens on an `n x n` chessboard such that no two queens threaten each other. This means no two queens can share the same row, column, or diagonal. \n\nThe core intuition is to use backtracking, a method that incrementally builds candidates to the solutions and abandons a candidate as soon as it determines that the candidate cannot possibly lead to a valid solution. Given the constraints, backtracking is an efficient approach because it prunes the search space by discarding invalid configurations early.\n\n### Approach\n\n1. **Backtracking Setup**: We use a recursive function to place queens row by row. We start from the first row and attempt to place a queen in each column of the current row. For each placement, we check if it's valid (i.e., no other queens can attack the current queen).\n\n2. **Validation Check**: For each attempted placement, we need to ensure:\n   - No other queen is in the same column.\n   - No other queen is on the same left diagonal.\n   - No other queen is on the same right diagonal.\n\n3. **Storing Solutions**: Once we place queens in all rows (i.e., reaching the base case of our recursion), we store the current board configuration as a valid solution.\n\n4. **Backtracking Step**: If placing a queen leads to an invalid configuration, we backtrack by removing the queen and trying the next column in the current row.\n\n5. **Result Formatting**: We format the final list of solutions where each solution is represented as a list of integers indicating the row positions of queens in each column.\n\n### Code\n\nHere is the implementation in C++:\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> ans;\n    \n    bool check(vector<vector<char>>& board, int i, int j) {\n        int x = i, y = j;\n        // Check upward direction\n        while(x >= 0) {\n            if(board[x][y] == 'Q') {\n                return false;\n            }\n            x--;\n        }\n        // Check left diagonal upward direction\n        x = i, y = j;\n        while(x >= 0 && y >= 0) {\n            if(board[x][y] == 'Q') return false;\n            x--;\n            y--;\n        }\n        // Check right diagonal upward direction\n        x = i, y = j;\n        while(x >= 0 && y < board.size()) {\n            if(board[x][y] == 'Q') return false;\n            x--;\n            y++;\n        }\n        return true;\n    }\n    \n    void insertAns(vector<vector<char>>& board) {\n        vector<int> row;\n        for(int i = 0; i < board.size(); i++) {\n            for(int j = 0; j < board.size(); j++) {\n                if(board[j][i] == 'Q') {\n                    row.push_back(j + 1);\n                    break;\n                }\n            }\n        }\n        if(row.size() == board.size()) {\n            ans.push_back(row);\n        }\n    }\n\n    void solve(vector<vector<char>>& board, int i, int n) {\n        if(i >= n) {\n            insertAns(board);\n            return;\n        }\n        \n        for(int j = 0; j < board.size(); j++) {\n            if(check(board, i, j)) {\n                board[i][j] = 'Q';\n                solve(board, i + 1, n);\n                board[i][j] = '-';\n            }\n        }\n    }\n\n    vector<vector<int>> nQueen(int n) {\n        vector<vector<char>> board(n, vector<char>(n, '-'));\n        solve(board, 0, n);\n        sort(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```\n\n### Explanation\n\n1. **Initialization**: A `board` of size `n x n` is initialized with all cells marked as empty (`'-'`).\n\n2. **Recursive Backtracking**:\n   - The function `solve` is called starting from the first row.\n   - For each column in the current row, it checks if placing a queen is valid using the `check` function.\n   - If valid, the queen is placed, and the function recursively attempts to place queens in the next row.\n   - If not valid, it tries the next column.\n\n3. **Validation**:\n   - The `check` function ensures no other queens are in the same column or diagonals.\n   - It does so by iterating upwards in the same column and both diagonals to check for any existing queens.\n\n4. **Storing Solutions**:\n   - When all rows are successfully filled with valid queen placements, `insertAns` records the current board configuration as a valid solution.\n   - It translates the board configuration into a list of integers representing the row positions of queens.\n\n5. **Final Output**:\n   - After all valid configurations are found, they are sorted and returned.\n\nThis approach ensures that all possible configurations are explored and only valid ones are retained, leveraging the efficiency of backtracking to handle the problem within feasible time constraints for the given input size.\n\nTo accomplish the task of generating input files for different test cases (basic, corner, edge, and boundary), running the solution, and storing the output in corresponding files, we need to structure our Python script in the following way:\n\n1. **Generate Test Cases**: Create the input files for all the specified test cases.\n2. **Run the Solution**: Execute the solution script (`solution.py`) with the generated input and capture the output.\n3. **Store the Output**: Save the captured output into corresponding output files.\n\nLet's start by writing the Python script to handle these tasks.\n\n### Step-by-Step Implementation:\n\n1. **Generate Test Cases**:\n    - Basic test cases: Simple and common scenarios.\n    - Corner test cases: Unusual or extreme scenarios.\n    - Edge test cases: Near the boundary of input constraints.\n    - Boundary test cases: Exactly at the boundary of input constraints.\n\n2. **Run the Solution**:\n    - Use `subprocess` to execute the solution script and capture its output.\n\n3. **Store the Output**:\n    - Write the output to the designated files.\n\nHere's the complete Python script:\n\n```python\nimport subprocess\n\n# Define the test cases\ntest_cases = {\n    \"basic\": [\n        1,  # Basic test case n=1\n        4,  # Basic test case n=4\n        5,  # Basic test case n=5\n        8   # Basic test case n=8\n    ],\n    \"corner\": [\n        2,  # Corner case n=2 (no solution)\n        3   # Corner case n=3 (no solution)\n    ],\n    \"edge\": [\n        10,  # Edge case n=10\n        11   # Edge case n=11\n    ],\n    \"boundary\": [\n        100000,  # Boundary case n=100000\n        99999    # Boundary case n=99999\n    ]\n}\n\n# Generate input files\ndef generate_input_files():\n    for case_type, cases in test_cases.items():\n        for i, case in enumerate(cases, start=1):\n            filename = f\"{case_type}_input_{i}.txt\"\n            with open(filename, \"w\") as f:\n                f.write(str(case))\n\n# Run solution.py and capture the output\ndef run_solution(input_file):\n    result = subprocess.run(['python3', 'solution.py'], input=open(input_file, \"r\"), text=True, capture_output=True)\n    return result.stdout\n\n# Store the output in corresponding files\ndef store_output_files():\n    for case_type, cases in test_cases.items():\n        for i, case in enumerate(cases, start=1):\n            input_filename = f\"{case_type}_input_{i}.txt\"\n            output_filename = f\"{case_type}_output_{i}.txt\"\n            output = run_solution(input_filename)\n            with open(output_filename, \"w\") as f:\n                f.write(output)\n\n# Main execution\nif __name__ == \"__main__\":\n    generate_input_files()\n    store_output_files()\n```\n\n### Explanation:\n\n1. **Test Cases Definition**:\n   - The `test_cases` dictionary stores the different cases categorized into `basic`, `corner`, `edge`, and `boundary`.\n\n2. **Generate Input Files**:\n   - The `generate_input_files` function iterates over the test cases and writes each case to a corresponding input file.\n\n3. **Run Solution**:\n   - The `run_solution` function uses `subprocess.run` to execute `solution.py` with the provided input file and capture the output.\n\n4. **Store Output Files**:\n   - The `store_output_files` function reads each input file, runs the solution, and writes the output to the corresponding output file.\n\n### Note:\n- Ensure the `solution.py` script is in the same directory as this script.\n- The `solution.py` should be adjusted to read from `stdin` if it currently reads from a file.\n\nThis script automates the creation of test cases, execution of the solution, and storage of outputs, which is essential for thorough testing and validation of the solution."
}